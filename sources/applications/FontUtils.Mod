MODULE FontUtils;
  IMPORT Files, Texts, Oberon;

  CONST FontFileId = 0DBH;

  TYPE RunRec = RECORD beg, end: INTEGER END;
    BoxRec = RECORD dx, x, y, w, h: INTEGER END ;

  VAR W: Texts.Writer;


  PROCEDURE chgExt(VAR name: ARRAY OF CHAR; ext: ARRAY OF CHAR);
    VAR i, j: INTEGER;
  BEGIN i := LEN(name);
    REPEAT DEC(i) UNTIL (i <= 0) OR (name[i] = "."); j := 0;
    WHILE ext[j] # 0X DO INC(i); name[i] := ext[j]; INC(j) END; name[i+1] := 0X
  END chgExt;

  PROCEDURE CRLF(VAR R: Files.Rider);
  BEGIN
    Files.Write(R, 0DX); Files.Write(R, 0AX); 
  END CRLF;

  PROCEDURE WriteString(VAR R: Files.Rider; s: ARRAY OF CHAR);
    VAR i: INTEGER;
  BEGIN i := 0; WHILE (i < LEN(s)) & (s[i] # 0X) DO Files.Write(R, s[i]); INC(i) END
  END WriteString;

  PROCEDURE doWriteInt(VAR R: Files.Rider; v: INTEGER);
  BEGIN
    IF v >= 10 THEN doWriteInt(R, v DIV 10) END;
    Files.Write(R, CHR(ORD("0") + v MOD 10))    
  END doWriteInt;

  PROCEDURE WriteInt(VAR R: Files.Rider; v: INTEGER);
    VAR i: INTEGER;
  BEGIN IF v < 0 THEN Files.Write(R, "-"); v := -v END;
    IF v = 0 THEN Files.Write(R, "0") ELSE doWriteInt(R, v) END 
  END WriteInt;

  PROCEDURE WriteHexDigit(VAR R: Files.Rider; v: BYTE);
  BEGIN
    IF v < 10 THEN Files.Write(R, CHR(ORD("0") + v)) ELSE Files.Write(R, CHR(ORD("A") + v-10)) END
  END WriteHexDigit;

  PROCEDURE WriteHex(VAR R: Files.Rider; v: BYTE);
    VAR i: INTEGER;
  BEGIN WriteHexDigit(R, v DIV 10H); WriteHexDigit(R, v MOD 10H); 
  END WriteHex;

  PROCEDURE fromHexa(c: CHAR): BYTE;
    VAR b: BYTE;
  BEGIN IF c >= "A" THEN ASSERT (c <="Z"); b := 10 + ORD(c) - ORD("A")
    ELSIF c >= "0" THEN ASSERT (c <="9"); b := ORD(c) - ORD("0")
    ELSE ASSERT(FALSE)
    END;

    RETURN b
  END fromHexa;

  PROCEDURE ToBDF*;
    VAR f!, g!: Files.File; Rf!, Rg!: Files.Rider;
      NofRuns, height, width, minX, maxX, minY, maxY: INTEGER;
      name: ARRAY 32 OF CHAR;
      S!: Texts.Scanner;
      b, ab, fam, var: BYTE;
      h, i, j, k, l, m, n, w, beg, end, NofBoxes: INTEGER;
      run: ARRAY 16 OF RunRec;
      box: ARRAY 512 OF BoxRec;
      bm: ARRAY 32*32 DIV 8 OF BYTE;

  PROCEDURE RdInt16(VAR R: Files.Rider; VAR x: INTEGER);
    VAR b0, b1: BYTE;
  BEGIN Files.ReadByte(R, b0); Files.ReadByte(R, b1);
    x := b0 + b1*100H;
    IF x > 8000H THEN x := x - 10000H END
  END RdInt16;

  BEGIN Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S);
    IF S.class = Texts.Name THEN name := S.s; f := Files.Old(name);
      IF f # NIL THEN Files.Set(Rf, f, 0); Files.ReadByte(Rf, ab);
        chgExt(name, "bdf"); g := Files.New(name); Files.Set(Rg, g, 0);
        IF ab = FontFileId THEN
          WriteString(Rg, "STARTFONT 2.1"); CRLF(Rg);
          WriteString(Rg, "FONT "); WriteString(Rg, name); CRLF(Rg);
          Files.ReadByte(Rf, ab); (*abstraction*)
          Files.ReadByte(Rf, fam); (*family*)
          Files.ReadByte(Rf, var); (*variant*)
          RdInt16(Rf, height); RdInt16(Rf, minX); RdInt16(Rf, maxX); RdInt16(Rf, minY); RdInt16(Rf, maxY); RdInt16(Rf, NofRuns); 
          width := maxX - minX + 1;
          WriteString(Rg, "SIZE "); WriteInt(Rg, height); WriteString(Rg, " 75 75"); CRLF(Rg);
          WriteString(Rg, "FONTBOUNDINGBOX "); WriteInt(Rg, width); WriteString(Rg, " "); WriteInt(Rg, height); WriteString(Rg, " ");
          WriteInt(Rg, minX); WriteString(Rg, " "); WriteInt(Rg, minY); CRLF(Rg);
          WriteString(Rg, "COMMENT "); Files.Write(Rg, 22X); WriteString(Rg, "Generated by FontUtils, https://github.com/ef15c/oberon_stm32f4.git");
          Files.Write(Rg, 22X); CRLF(Rg);
          WriteString(Rg, "STARTPROPERTIES 6"); CRLF(Rg);
          WriteString(Rg, "ABSTRACTION "); WriteInt(Rg, ab); CRLF(Rg);
          WriteString(Rg, "FAMILY "); WriteInt(Rg, fam); CRLF(Rg);
          WriteString(Rg, "VARIANT "); WriteInt(Rg, var); CRLF(Rg);
          WriteString(Rg, "CHARSET_REGISTRY ANSI"); CRLF(Rg);
          WriteString(Rg, "FONT_ASCENT "); WriteInt(Rg, maxY); CRLF(Rg);
          WriteString(Rg, "FONT_DESCENT "); WriteInt(Rg, -minY); CRLF(Rg);
          WriteString(Rg, "ENDPROPERTIES"); CRLF(Rg);
          (*compute the number of glyphs in the font*)
          NofBoxes := 0; k := 0;
          WHILE k # NofRuns DO
            RdInt16(Rf, beg);
            run[k].beg := beg; RdInt16(Rf, end);
            run[k].end := end; NofBoxes := NofBoxes + end - beg; INC(k)
          END;
          WriteString(Rg, "CHARS "); WriteInt(Rg, NofBoxes); CRLF(Rg);
          j := 0;
          WHILE j # NofBoxes DO
            RdInt16(Rf, box[j].dx); RdInt16(Rf, box[j].x); RdInt16(Rf, box[j].y);
            RdInt16(Rf, box[j].w); RdInt16(Rf, box[j].h);
            INC(j)
          END;
          k :=0; j := 0;
          WHILE k < NofRuns DO
            FOR m := run[k].beg TO run[k].end - 1 DO
              WriteString(Rg, "STARTCHAR "); WriteInt(Rg, m); CRLF(Rg);
              WriteString(Rg, "ENCODING "); WriteInt(Rg, m); CRLF(Rg);
              WriteString(Rg, "SWIDTH "); WriteInt(Rg, box[j].dx*1000 DIV width); WriteString(Rg, " 0"); CRLF(Rg);
              WriteString(Rg, "DWIDTH "); WriteInt(Rg, box[j].dx); WriteString(Rg, " 0"); CRLF(Rg);
              WriteString(Rg, "BBX "); WriteInt(Rg, box[j].w); WriteString(Rg, " "); WriteInt(Rg, box[j].h);
              WriteString(Rg, " "); WriteInt(Rg, box[j].x); WriteString(Rg, " "); WriteInt(Rg, box[j].y); CRLF(Rg);
              WriteString(Rg, "BITMAP"); CRLF(Rg);
              w := box[j].w; h := box[j].h; l := (w + 7) DIV 8;
              FOR i := 0 TO  (w + 7) DIV 8*h-1 DO Files.ReadByte(Rf, bm[i]) END;
              FOR i := 1 TO h DO
                FOR n := 0 TO l-1 DO WriteHex(Rg, LSR(RBIT(bm[(h-i)*l + n]), 24)) END;
                CRLF(Rg)
              END ;
              INC(j);
              WriteString(Rg, "ENDCHAR"); CRLF(Rg);
            END;
            INC(k)
          END;
          WriteString(Rg, "ENDFONT"); CRLF(Rg);

          Files.Register(g); Texts.WriteString(W, "font converted in "); Texts.WriteString(W, name);
        ELSE Texts.WriteString(W, "bad file id")
        END
      ELSE Texts.WriteString(W, "file "); Texts.WriteString(W, name); Texts.WriteString(W, " not found")
      END
    ELSE Texts.WriteString(W, "Usage: FontUtils.ToBDF <fontName>")
    END;
    Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf)
  END ToBDF;

  PROCEDURE FromBDF*;
    VAR g!: Files.File; Rg!: Files.Rider;
      Sc!, St!: Texts.Scanner; T!: Texts.Text;
      name: ARRAY 32 OF CHAR;
      height, width, minX, minY, res, glyphPos, end: INTEGER;
      i, j, k, l, m: INTEGER;
      bm: ARRAY 32*32 DIV 8 OF BYTE;
      ch: CHAR;
      NofRuns, NofBoxes: INTEGER;
      run: ARRAY 16 OF RunRec;
      box: ARRAY 512 OF BoxRec;

    PROCEDURE WrInt16(VAR W: Files.Rider; x: INTEGER);
    BEGIN Files.WriteByte(W, x MOD 100H); Files.WriteByte(W, x DIV 100H MOD 100H)
    END WrInt16;

  BEGIN Texts.OpenScanner(Sc, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(Sc);
    IF Sc.class = Texts.Name THEN name := Sc.s; NEW(T); Texts.Open(T, name);
      IF T.len > 0 THEN Texts.OpenScanner(St, T, 0); Texts.Scan(St);
        chgExt(name, "Fnt"); g := Files.New(name); Files.Set(Rg, g, 0);  Files.WriteByte(Rg, FontFileId); res := 0;
        IF (St.class = Texts.Name) & (St.s = "STARTFONT") THEN Texts.Scan(St);
        ELSE Texts.WriteString(W, "missing STARTFONT keyword"); res := -1;
        END;
        IF res = 0 THEN IF (St.class = Texts.Real) & (St.x <= 2.1) THEN Texts.Scan(St)
          ELSE Texts.WriteString(W, "bad file version"); res := -1 END
        END;
        IF res = 0 THEN 
          IF (St.class = Texts.Char) & (St.c = 0AX) THEN Texts.Scan(St);
            WHILE (res = 0) & ~St.eot & ((St.class # Texts.Name) OR (St.s # "SIZE")) DO Texts.Scan(St) END;
            IF St.eot THEN Texts.WriteString(W, "missing SIZE keyword"); res := -1 ELSE Texts.Scan(St) END;
            IF (res = 0) & (St.class = Texts.Int) THEN height := St.i; Texts.Scan(St)
            ELSE Texts.WriteString(W, "missing font size"); res := -1 END
          END
        END;
        WHILE (res = 0) & ~St.eot & ((St.class # Texts.Char) OR (St.c # 0AX)) DO Texts.Scan(St) END;
        IF (res = 0) & (St.class = Texts.Char) & (St.c = 0AX) THEN Texts.Scan(St) ELSE res := -1 END;
        IF res = 0 THEN IF (St.class = Texts.Name) & (St.s = "FONTBOUNDINGBOX") THEN Texts.Scan(St)
          ELSE Texts.WriteString(W, "missing FONTBOUNDINGBOX keyword"); res := -1 END
        END;
        IF res = 0 THEN IF (St.class = Texts.Int) THEN width := St.i; Texts.Scan(St); Texts.Scan(St)
          ELSE Texts.WriteString(W, "missing font bounding box width"); res := -1 END
        END;
        IF res = 0 THEN IF (St.class = Texts.Int) THEN minX := St.i; Texts.Scan(St)
        ELSE Texts.WriteString(W, "missing font bounding box Xoff"); res := -1 END
        END;
        IF res = 0 THEN IF (St.class = Texts.Int) THEN minY := St.i; Texts.Scan(St)
        ELSE Texts.WriteString(W, "missing font bounding box Yoff"); res := -1 END
        END;
        IF res = 0 THEN
          WHILE ~St.eot & ((St.class # Texts.Name) OR (St.s # "STARTPROPERTIES")) DO Texts.Scan(St) END;
          IF St.eot THEN Texts.WriteString(W, "missing STARTPROPERTIES keyword"); res := -1 ELSE Texts.Scan(St) END
        END;
        WHILE (res = 0) & ~St.eot & ((St.class # Texts.Char) OR (St.c # 0AX)) DO Texts.Scan(St) END;
        IF (res = 0) & (St.class = Texts.Char) & (St.c = 0AX) THEN Texts.Scan(St) ELSE res := -1 END;
        IF res = 0 THEN IF (St.class = Texts.Name) & (St.s = "ABSTRACTION") THEN Texts.Scan(St)
          ELSE Texts.WriteString(W, "missing ABSTRACTION property"); res := -1 END
        END;
        IF res = 0 THEN IF (St.class = Texts.Int) THEN Files.WriteByte(Rg, St.i); Texts.Scan(St)
        ELSE Texts.WriteString(W, "missing ABSTRACTION value"); res := -1 END
        END;
        IF (res = 0) & (St.class = Texts.Char) & (St.c = 0AX) THEN Texts.Scan(St);
          IF (St.class = Texts.Name) & (St.s = "FAMILY") THEN Texts.Scan(St)
          ELSE Texts.WriteString(W, "missing FAMILY property"); res := -1 END
        END;
        IF res = 0 THEN IF (St.class = Texts.Int) THEN Files.WriteByte(Rg, St.i); Texts.Scan(St)
        ELSE Texts.WriteString(W, "missing FAMILY value"); res := -1 END
        END;
        IF (res = 0) & (St.class = Texts.Char) & (St.c = 0AX) THEN Texts.Scan(St);
          IF (St.class = Texts.Name) & (St.s = "VARIANT") THEN Texts.Scan(St)
          ELSE Texts.WriteString(W, "missing VARIANT property"); res := -1 END
        END;
        IF res = 0 THEN IF (St.class = Texts.Int) THEN Files.WriteByte(Rg, St.i); Texts.Scan(St);
          WrInt16(Rg, height); WrInt16(Rg, minX); WrInt16(Rg, minX + width); WrInt16(Rg, minY); WrInt16(Rg, minY + height); 
        ELSE Texts.WriteString(W, "missing FAMILY value"); res := -1 END
        END;
        IF res = 0 THEN
          WHILE ~St.eot & ((St.class # Texts.Name) OR (St.s # "CHARS")) DO Texts.Scan(St) END;
          IF St.eot THEN Texts.WriteString(W, "missing CHARS keyword"); res := -1 ELSE Texts.Scan(St) END
        END;
        IF (res = 0) & (St.class = Texts.Int) THEN NofBoxes := St.i; Texts.Scan(St)
        ELSE Texts.WriteString(W, "missing CHARS value"); res := -1 END;
        IF res = 0 THEN glyphPos := Texts.Pos(St); NofRuns := 0; end := NofBoxes + 1; i := 0;
          WHILE ~St.eot & (res = 0) & (i < NofBoxes) DO
            WHILE ~St.eot & ((St.class # Texts.Name) OR (St.s # "STARTCHAR")) DO Texts.Scan(St) END;
            IF St.eot THEN Texts.WriteString(W, "missing STARTCHAR keyword"); res := -1 ELSE Texts.Scan(St) END;
            IF res = 0 THEN
              WHILE ~St.eot & ((St.class # Texts.Name) OR (St.s # "ENCODING")) DO Texts.Scan(St) END;
              IF St.eot THEN Texts.WriteString(W, "missing ENCODING keyword"); res := -1 ELSE Texts.Scan(St) END
            END;
            IF (res = 0) & (St.class = Texts.Int) THEN
              IF St.i # end + 1 THEN
                IF NofRuns > 0 THEN run[NofRuns - 1].end := end + 1 (*close previous run*) END;
                run[NofRuns].beg := St.i; INC(NofRuns) (*open a new run*)
              END; end := St.i; Texts.Scan(St)
            ELSE Texts.WriteString(W, "missing ENCODING value"); res := -1 
            END;
            IF res = 0 THEN
              WHILE ~St.eot & ((St.class # Texts.Name) OR (St.s # "DWIDTH")) DO Texts.Scan(St) END;
              IF St.eot THEN Texts.WriteString(W, "missing DWIDTH keyword"); res := -1 ELSE Texts.Scan(St) END;
            END;
            IF (res = 0) & (St.class = Texts.Int) THEN box[i].dx := St.i; Texts.Scan(St)
            ELSE Texts.WriteString(W, "missing ENCODING value"); res := -1 
            END;
            IF res = 0 THEN
              WHILE ~St.eot & ((St.class # Texts.Name) OR (St.s # "BBX")) DO Texts.Scan(St) END;
              IF St.eot THEN Texts.WriteString(W, "missing BBX keyword"); res := -1 ELSE Texts.Scan(St) END;
            END;
            IF (res = 0) & (St.class = Texts.Int) THEN box[i].w := St.i; Texts.Scan(St)
            ELSE Texts.WriteString(W, "missing BBX width value"); res := -1 
            END;
            IF (res = 0) & (St.class = Texts.Int) THEN box[i].h := St.i; Texts.Scan(St)
            ELSE Texts.WriteString(W, "missing BBX heigth value"); res := -1 
            END;
            IF (res = 0) & (St.class = Texts.Int) THEN box[i].x := St.i; Texts.Scan(St)
            ELSE Texts.WriteString(W, "missing BBX offset X value"); res := -1 
            END;
            IF (res = 0) & (St.class = Texts.Int) THEN box[i].y := St.i; Texts.Scan(St)
            ELSE Texts.WriteString(W, "missing BBX offset Y value"); res := -1 
            END;
            INC(i)
          END;
          IF res = 0 THEN IF i = NofBoxes THEN
            IF NofRuns > 0 THEN run[NofRuns - 1].end := end + 1 (*close last run*) END
          ELSE Texts.WriteInt(W,  NofBoxes - i, 1); Texts.WriteString(W, "glyphs are missing in file"); res := -1
          END;
          IF res = 0 THEN WrInt16(Rg, NofRuns);
            FOR i := 0 TO NofRuns - 1 DO WrInt16(Rg, run[i].beg); WrInt16(Rg, run[i].end) END;
            FOR i := 0 TO NofBoxes - 1 DO WrInt16(Rg, box[i].dx); WrInt16(Rg, box[i].x);
              WrInt16(Rg, box[i].y); WrInt16(Rg, box[i].w); WrInt16(Rg, box[i].h)
            END;
            Texts.OpenScanner(St, T, glyphPos); (*rewind input file to beginning of BITMAP data*)
            i := 0;
          END;
          WHILE ~St.eot & (res = 0) & (i < NofBoxes) DO
            WHILE ~St.eot & ((St.class # Texts.Name) OR (St.s # "BITMAP")) DO Texts.Scan(St) END;
            IF St.eot THEN Texts.WriteString(W, "missing BITMAP keyword"); res := -1 ELSE Texts.Scan(St) END;
            IF res = 0 THEN l := (box[i].w + 7) DIV 8; j := 1; m := 0;
              WHILE (res = 0) & (j <= box[i].h) DO 
                WHILE ~St.eot & (res = 0) & ((St.class # Texts.Char) OR (St.c # 0AX)) DO Texts.Scan(St) END;
                IF (St.class  = Texts.Char) & (St.c = 0AX) THEN ch := St.nextCh; glyphPos := Texts.Pos(St);
                  FOR k := 0 TO l-1 DO
                    bm[m] := fromHexa(ch)*10H; Texts.Read(St, ch); INC(bm[m], fromHexa(ch)); Texts.Read(St, ch);
                    INC(m)
                   END;
                  Texts.OpenScanner(St, T, glyphPos + 2*l); Texts.Scan(St);
                  IF (St.class # Texts.Char) OR (St.c # 0AX) THEN Texts.WriteString(W, "pos "); Texts.WriteInt(W, Texts.Pos(St), 1);
                    Texts.WriteString(W, " end of line expected after BITMAP data line"); res := -1
                  END
                ELSE res := -1
                END;
               INC(j)
              END;
              WHILE m # 0 DO DEC(m, l); FOR j := m TO m + l -1 DO Files.WriteByte(Rg, LSR(RBIT(bm[j]), 24)) END END
            END;
            IF res = 0 THEN
              WHILE ~St.eot & (res = 0) & ((St.class # Texts.Char) OR (St.c # 0AX)) DO Texts.Scan(St) END;
              IF (St.class  = Texts.Char) & (St.c = 0AX) THEN Texts.Scan(St);
                IF (St.class = Texts.Name) & (St.s = "ENDCHAR") THEN Texts.Scan(St)
                ELSE Texts.WriteString(W, "missing ENDCHAR keyword"); res := -1
                END
              ELSE res := -1
              END
            END;
            INC(i)
          END;
          IF res = 0 THEN 
            IF i # NofBoxes THEN Texts.WriteInt(W,  NofBoxes - i, 1); Texts.WriteString(W, "glyphs are missing in file"); res := -1 END
          END;
          IF res = 0 THEN Files.Register(g);
            Texts.WriteInt(W, NofBoxes, 1); Texts.WriteString(W, " glyphs converted in "); Texts.WriteString(W, name)
          END
        END
      END
      ELSE Texts.WriteString(W, "file "); Texts.WriteString(W, name); Texts.WriteString(W, " not found")
      END
    ELSE Texts.WriteString(W, "Usage: FontUtils.ToBDF <fontName>")
    END;
    Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf)
  END FromBDF;

BEGIN Texts.OpenWriter(W)
END FontUtils.
